{"version":3,"sources":["../src/index.jsx"],"names":["isType","type","val","undefined","includes","constructor","isInstanceOf","isNormalFunction","f","name","toLowerCase","isConstructor","err","isPrimitive","value","Object","checkShape","shape","normalPropsName","keys","filter","prop","isRegExp","every","key","isValidType","checkRegExp","regExp","test","props","propName","RegExp","Array","some","_type","testOrWarn","error","console","log","stringToRegExp","string","eval","stringRegExp","notIsRegExp","typedComponent","types","defaults","Component","propsToTest","regExpToCheck","untestedReceivedProps","forEach","regexpString","testedProps","_props"],"mappings":"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","sourcesContent":["import React from 'react';\n\nexport const isType = type => val =>\n  ![undefined, null].includes(val) && val.constructor === type;\n\nexport const isInstanceOf = type => val => val instanceof type;\n\nexport const isNormalFunction = f =>\n  typeof f === 'function' &&\n  (!f.name || f.name[0] === f.name[0].toLowerCase());\n\nexport function isConstructor(f) {\n  // detect is a normal function (anonymous or its name starts with lowercase)\n  if (isNormalFunction(f)) return false;\n\n  try {\n    new f();\n  } catch (err) {\n    return false;\n  }\n  return true;\n}\n\nexport const isPrimitive = value => !(value instanceof Object);\n// export const isPrimitive = value => Object(value) !== value;\n\nexport const checkShape = (shape, value) => {\n\n  // const regExpPropsName = Object.keys(shape).filter(isRegExp);\n  // const untestedPropsName = Object.key(value).filter(isRegExp);\n  const normalPropsName = Object.keys(shape).filter(prop => !isRegExp(prop));\n  // regExpPropsName.forEach( regexString => )\n  return normalPropsName.every(key =>\n    isValidType(shape[key], value[key]),\n  );\n  //   // const regExpPropsName = Object.keys(shape).filter(isRegExp);\n  // const normalPropsName = Object.keys(shape).filter(prop => !isRegExp(prop));\n  // const untestedPropsName = Object.key(value).filter(name => !normalPropsName.includes(name));\n\n  // let areValid = true\n  // // regExpPropsName.forEach(regexpString => {\n  // //   areValid = untestedPropsName.every(propName =>\n  // //     stringToRegExp(regexpString).test(propName),\n  // //   );\n  // // });\n\n  // areValid = normalPropsName.every(\n  //   key => isValidType(shape[key], value[key]),\n  // );\n\n  // return areValid\n\n\n\n}\n\nconst checkRegExp = (regExp, value) => regExp.test(value);\n\nexport const isValidType = (type, value, props, propName) => {\n  if (isType(RegExp)(type)) {\n    return checkRegExp(type, value);\n  } else if (isPrimitive(type)) {\n    return value === type;\n  } else if (isNormalFunction(type)) {\n    return type(value, props, propName);\n  } else if (isConstructor(type)) {\n    return isType(type)(value);\n  } else if (isType(Array)(type)) {\n    return type.some(_type => isValidType(_type, value));\n  } else if (isType(Object)(type) && isType(Object)(value)) {\n    return checkShape(type, value);\n  }\n  return false;\n};\n\nconst testOrWarn = (type, value, props, propName) => {\n  try {\n    isValidType(type, value, props, propName) ||\n      error(\n        `prop ${propName} with value ${value} do not match type ${type}`,\n      );\n  } catch (error) {\n    error(error);\n  }\n};\n\nconst error = (...args) => {\n  console.error(...args);\n  console.log(...args);\n};\n\nconst stringToRegExp = string => new RegExp(eval(string));\n\nconst stringRegExp = /^\\/.+\\/$/;\nconst isRegExp = value => value && stringRegExp.test(value);\nconst notIsRegExp = value => !isRegExp(value);\nconst typedComponent = (\n  types = {},\n  defaults = {},\n) => Component => props => {\n  const propsToTest = Object.keys(types).filter(notIsRegExp);\n  const regExpToCheck = Object.keys(types).filter(isRegExp);\n  const untestedReceivedProps = Object.keys(props).filter(\n    propName => !propsToTest.includes(propName),\n  );\n\n  // console.log('propsToTest', propsToTest);\n  // console.log('regExpToCheck', regExpToCheck);\n  // console.log('untestedReceivedProps', untestedReceivedProps);\n\n  propsToTest.forEach(propName =>\n    testOrWarn(\n      types[propName],\n      props[propName],\n      props,\n      propName,\n    ),\n  );\n  regExpToCheck.forEach(regexpString => {\n    untestedReceivedProps.forEach(propName => {\n      if (stringToRegExp(regexpString).test(propName)) {\n        testOrWarn(\n          types[regexpString],\n          props[propName],\n          props,\n          propName,\n        );\n      }\n    });\n  });\n\n  const testedProps = propsToTest.filter(\n    ([propName]) => !isRegExp(propName),\n  );\n  // const regExpPropNameArray = allPropNameToCheck\n  // const allPropNameToCheck = Object.keys(types);\n\n  // const regExpPropNameArray = allPropNameToCheck.filter(\n  //   propName => stringRegExp.test(propName),\n  // );\n\n  // const stringPropNameArray = allPropNameToCheck.filter(\n  //   propName => !stringRegExp.test(propName),\n  // );\n\n  //  CHECK PROP NAME WITH REGEXP\n  //\n  // const propsToCheckByRegExp = Object.keys(props).filter(\n  //   propName => !stringPropNameArray.includes(propName),\n  // );\n\n  // for (const regExpPropName of regExpPropNameArray) {\n  //   const regExp = stringToRegExp(types[regExpPropName]);\n  //   for (const propName of propsToCheckByRegExp) {\n  //     if(regExp.test(propName)) {\n  //       const value = props[propName];\n  //       const type = types[regExpPropName];\n\n  //       try {\n  //         isValidType(type, value, props, propName) ||\n  //           error(\n  //             `prop ${propName} with value ${value} do not match type ${type}`,\n  //           );\n  //       } catch (error) {\n  //         error(error);\n  //       }\n  //     }\n  //   }\n  // }\n\n  // for (const propName of stringPropNameArray) {\n  //   const value = props[propName];\n  //   const type = types[propName];\n  //   if (typeof value === 'undefined') {\n  //     continue;\n  //   }\n\n  //   try {\n  //     isValidType(type, value, props, propName) ||\n  //       error(\n  //         `prop ${propName} with value ${value} do not match type ${type}`,\n  //       );\n  //   } catch (error) {\n  //     error(error);\n  //   }\n  // }\n\n  // for (const prop in types) {\n  //   if (types.hasOwnProperty(prop)) {\n\n  //   }\n  // }\n  const _props = {\n    ...defaults,\n    ...props,\n  };\n\n  return <Component {..._props} />;\n};\n\nexport default typedComponent;\n"],"file":"index.js"}